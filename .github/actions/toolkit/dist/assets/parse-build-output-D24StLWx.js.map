{"version":3,"file":"parse-build-output-D24StLWx.js","sources":["../../src/lib/config.ts","../../src/commands/parse-build-output.ts"],"sourcesContent":["import * as core from \"@actions/core\";\n\ntype ConfigValues = {\n    token: string | undefined;\n    \"oras-bundle-type\": string;\n    \"oras-actor\": string | undefined;\n    \"output-cache-path\": string;\n};\n\ntype ConfigKey = keyof ConfigValues;\n\ntype ConfigValuesFunctions = {\n    [K in keyof ConfigValues]: () => ConfigValues[K] | ConfigValues[K];\n};\n\nexport function getConfigValue<T extends ConfigKey>(key: T): ConfigValues[T] {\n    const values: ConfigValuesFunctions = {\n        token: () => core.getInput(\"token\") ?? process.env.GITHUB_TOKEN,\n        \"oras-bundle-type\": () =>\n            core.getInput(\"oras-bundle-type\") ?? \"unknown/unknown\",\n        \"oras-actor\": () =>\n            core.getInput(\"oras-actor\") ?? process.env.GITHUB_ACTOR,\n        \"output-cache-path\": () => core.getInput(\"output-cache-path\"),\n    };\n\n    return values[key]();\n}\n","import * as core from \"@actions/core\";\nimport * as fs from \"node:fs/promises\";\nimport { tmpdir } from \"node:os\";\nimport { sep } from \"path\";\nimport { runCommand } from \"/lib/action\";\nimport { getConfigValue } from \"/lib/config\";\nimport { getCommandOutput } from \"/lib/tools\";\nimport { DefaultArtifactClient } from \"@actions/artifact\";\nimport { dirname } from \"node:path\";\nexport { command as runCommand };\n\nconst command = runCommand({\n    post: async function () {\n        const frontendBundle = core.getState(\"frontendBundle\");\n        const frontendImage = core.getState(\"frontendImage\");\n        if (!frontendBundle || !frontendImage) {\n            core.info(\"No frontend bundle to attach.\");\n            return;\n        }\n\n        core.info(\"Uploading frontend bundle as GHA artifact...\");\n        const artifact = new DefaultArtifactClient();\n\n        await artifact\n            .uploadArtifact(\n                \"frontend-bundle\",\n                [frontendBundle],\n                dirname(frontendBundle),\n            )\n            .then(({ size, id }) => {\n                core.info(\n                    `Uploaded frontend bundle as artifact, id: ${id}, size: ${size}`,\n                );\n            })\n            .catch((reason: unknown) => {\n                core.error(\"Failed to create GHA artifact.\");\n                core.setFailed(\n                    \"Failed to upload frontend bundle as GHA artifact: \" +\n                        reason,\n                );\n            });\n\n        const artifactType = getConfigValue(\"oras-bundle-type\");\n        const actor = getConfigValue(\"oras-actor\");\n        const token = getConfigValue(\"token\");\n\n        try {\n            await getCommandOutput(\"docker\", [\n                \"manifest\",\n                \"inspect\",\n                frontendImage,\n            ]);\n        } catch {\n            core.info(\"Frontend image not found in registry: \" + frontendImage);\n            return;\n        }\n        core.info(\"Attaching frontend bundle to image: \" + frontendImage);\n        const orasLoginOpts: string[] = [];\n        orasLoginOpts\n            .concat(!!actor ? [\"--username\", actor] : [])\n            .concat(!!token ? [\"--password\", token] : []);\n\n        await getCommandOutput(\"oras\", orasLoginOpts).catch(\n            (error: unknown) => {\n                core.error(\"Failed to login to registry.\");\n                core.setFailed(\"ORAS Failed to login to registry\");\n                throw error;\n            },\n        );\n\n        await getCommandOutput(\"oras\", [\n            \"attach\",\n            frontendImage,\n            \"--disable-path-validation\",\n            \"--artifact-type\",\n            artifactType,\n            frontendBundle,\n        ]).catch((error: unknown) => {\n            core.error(\"Failed to attach bundle to image.\");\n            core.setFailed(\"ORAS Failed to attach bundle to image\");\n            throw error;\n        });\n    },\n    main: async function () {\n        parseDockerMeta(core.getInput(\"docker-metadata\"));\n\n        const outputCachePath = getConfigValue(\"output-cache-path\");\n        await extractOutputCache(outputCachePath);\n\n        //Check if a frontend-bundle was written to the output cache.\n        const bundlePath = `${outputCachePath}/web-build/frontend-bundle.tar.gz`;\n\n        try {\n            fs.access(bundlePath, fs.constants.R_OK);\n        } catch (err) {\n            core.debug(\"No frontend bundle found at: \" + bundlePath);\n            core.info(\"No frontend bundle found.\");\n            return;\n        }\n        core.saveState(\"frontendBundle\", bundlePath);\n        core.setOutput(\"frontend-bundle\", bundlePath);\n    },\n});\n\nfunction parseDockerMeta(bakeMetaOutput: string) {\n    const meta = JSON.parse(bakeMetaOutput).catch((reason: unknown) =>\n        core.error(\"core.error parsing docker bake metadata: \" + reason),\n    );\n    if (!meta) {\n        return;\n    }\n    const webTarget = Object.keys(meta).find((key) => key.endsWith(\"web\"));\n    const webImage = webTarget ? meta[webTarget].image.name : null;\n    core.saveState(\"frontendImage\", webImage);\n    core.saveState(\"webTarget\", webTarget);\n}\n\nasync function extractOutputCache(cachePath: string) {\n    const dockerBuildDir = await fs.mkdtemp(`${tmpdir()}${sep}output-cache-`);\n    const dockerfile = \"./.github/actions/toolkit/Dockerfile.extract-cache\";\n    //Generate a timestamp to use to prevent docker from caching\n    const buildStamp = new Date().toISOString();\n\n    await getCommandOutput(\"docker\", [\n        \"buildx\",\n        \"build\",\n        \"-f \" + dockerfile,\n        \"--tag output:extract\",\n        \"--build-arg BUILDSTAMP=\" + buildStamp,\n        \"--load\",\n        dockerBuildDir,\n    ]);\n    core.info(\"Building cache extractor image...\");\n    await getCommandOutput(\"docker\", [\"rm\", \"-f\", \"cache-container\"]);\n    core.info(\"Creating cache extractor...\");\n    await getCommandOutput(\"docker\", [\n        \"create\",\n        \"-ti\",\n        \"--name cache-container\",\n        \"output:extract\",\n    ]);\n    core.info(\"Copying cache from extractor...\");\n    await getCommandOutput(\"docker\", [\n        \"cp\",\n        \"-L\",\n        \"cache-container:/var/.output-cache\",\n        cachePath,\n    ]);\n}\n"],"names":["getConfigValue","key","core.getInput","define_process_env_default","command","runCommand","frontendBundle","core.getState","frontendImage","core.info","DefaultArtifactClient","dirname","size","id","reason","core.error","core.setFailed","artifactType","actor","token","getCommandOutput","orasLoginOpts","error","parseDockerMeta","outputCachePath","extractOutputCache","bundlePath","fs","core.debug","core.saveState","core.setOutput","bakeMetaOutput","meta","webTarget","webImage","cachePath","dockerBuildDir","tmpdir","sep","dockerfile","buildStamp"],"mappings":"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"}