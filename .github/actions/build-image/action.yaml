name: Build
description: "Builds the Docker images for Pilcrow"
inputs:
  target:
    description: "package to build"
    required: false
    default: "ci"
  token:
    description: "GitHub token to use for authentication"
outputs:
  version:
    description: "Version of the package that was built"
    value: ${{ steps.docker-meta.outputs.version }}
  web_image:
    description: "Web image name that was built"
    value: ${{ env.WEB_IMAGE }}
  fpm_image:
    description: "FPM image name that was built"
    value: ${{ env.FPM_IMAGE }}
  tags:
    description: "List of tags"
    value: ${{ steps.docker-meta.outputs.tags}}
  frontend_bundle:
    description: "Path to the frontend bundle"
    value: ${{ steps.frontend-bundle.outputs.bundle_file }}

runs:
  using: "composite"
  steps:
    - name: Pre-build setup
      id: tagger
      shell: bash
      run: |
        VERSION=$(git describe --tags --match "v*")
        VERSION_URL=https://github.com/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}
        VERSION_DATE=$(git show -s --format=%cI ${GITHUB_SHA})
        REPO=${GITHUB_REPOSITORY,,}
        DOCKER_IMAGE_CACHE=ghcr.io/${REPO}/cache/__service__
        echo "VERSION=${VERSION}" >> "$GITHUB_ENV"
        echo "VERSION_URL=${VERSION_URL}" >> "$GITHUB_ENV"
        echo "VERSION_DATE=${VERSION_DATE}" >> "$GITHUB_ENV"
        echo "REPO=${REPO}" >> "$GITHUB_ENV"
        echo "DOCKER_IMAGE_CACHE=${DOCKER_IMAGE_CACHE}" >> "$GITHUB_ENV"
        if [ "${{ inputs.target }}" == "release" ]; then
            echo "IMAGE_BASE=ghcr.io/${REPO}/__service__" >> "$GITHUB_ENV"
        else
            echo "IMAGE_BASE=${DOCKER_IMAGE_CACHE}" >> "$GITHUB_ENV"
        fi
        sudo apt install -y colorized-logs
    - uses: docker/setup-buildx-action@v3
      id: buildx
    - name: Cache
      uses: actions/cache@v3
      id: docker-yarn-cache
      with:
        path: |
          yarn-v6-cache
        key: cache-yarn-${{ hashFiles('client/package.json', 'client/yarn.lock') }}
    - name: inject cache into docker
      uses: reproducible-containers/buildkit-cache-dance@v3.1.0
      with:
        cache-map: |
          {
            "yarn-v6-cache": "/usr/local/share/.cache/yarn/v6"
          }
        skip-extraction: ${{ steps.docker-yarn-cache.outputs.cache-hit }}
    - name: Docker Meta
      id: docker-input-metadata
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.IMAGE_BASE }}
        tags: |
          type=edge
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,enable=${{ inputs.target == 'ci'}}
    - uses: int128/docker-build-cache-config-action@v1
      id: docker-registry-cache
      with:
        image: ${{ env.DOCKER_IMAGE_CACHE }}
    - name: Consolidate Docker Bake Files
      shell: bash
      id: cp-bake-files
      run: |
        BAKEDIR=${RUNNER_TEMP}/pilcrow-bake
        echo "path=${BAKEDIR}/" >> "$GITHUB_OUTPUT"
        mkdir -p $BAKEDIR
        cp ./docker-bake.hcl \
        ${{ steps.docker-registry-cache.outputs.bake-file }} \
        ${{ steps.docker-input-metadata.outputs.bake-file }} \
        $BAKEDIR
    - name: Upload Docker Bake Files
      uses: actions/upload-artifact@v4
      with:
        name: docker-bake-src-${{ inputs.target }}
        path: ${{ steps.cp-bake-files.outputs.path }}
    - name: Build and push
      id: docker-bake
      uses: docker/bake-action@v6.8.0
      with:
        source: .
        targets: ${{ inputs.target }}
        allow: fs.write=*
        files: |
          ./docker-bake.hcl
          ${{ steps.docker-input-metadata.outputs.bake-file }}
          ${{ steps.docker-registry-cache.outputs.bake-file }}
    - name: Extract Image Registry/Tags from Metadata
      id: docker-output-metadata
      env:
        METADATA: ${{ steps.docker-bake.outputs.metadata }}
        BUNDLE_PATH: build/web/bundle
      shell: bash
      run: |
        WEB_IMAGE="$(echo $METADATA | jq -r 'to_entries[] | select(.key|endswith("web")).value."image.name"')"
        FPM_IMAGE="$(echo $METADATA | jq -r 'to_entries[] | select(.key|endswith("fpm")).value."image.name"')"
        BUNDLE_EXISTS="$(if [[ -d "${BUNDLE_PATH}" ]]; then echo "${BUNDLE_PATH}"; else echo ""; fi)"
        echo "web-image=${WEB_IMAGE}" >> "$GITHUB_OUTPUT"
        echo "fpm-image=${FPM_IMAGE}" >> "$GITHUB_OUTPUT"
        echo "bundle-path=${BUNDLE_EXISTS}" >> "$GITHUB_OUTPUT"
    - name: Upload Frontend Bundle as Github Artifact
      uses: actions/upload-artifact@v4
      if: ${{ steps.docker-output-metadata.outputs.bundle-path != '' }}
      with:
        name: frontend-bundle
        path: ${{steps.docker-output-metadata.outputs.bundle-path}}/spa/
        if-no-files-found: warn
    - name: Output Quasar Build Summary
      if: ${{ steps.docker-output-metadata.outputs.bundle-path != '' }}
      env:
        OUTPUT_PATH: ${{ steps.docker-output-metadata.outputs.bundle-path }}
      shell: bash
      run: |
        echo '## Quasar Build Summary' >> "$GITHUB_STEP_SUMMARY"
        ERROR_FILE="${OUTPUT_PATH}/errors.txt"
        if [[ -s "${ERROR_FILE}" ]]; then
          echo "> [!WARNING]" > "$GITHUB_STEP_SUMMARY"
          echo "> Quasar wrote to stderr during the build process." >> "$GITHUB_STEP_SUMMARY"
          echo '### Output from STDERR' >> "$GITHUB_STEP_SUMMARY"
          cat "${ERROR_FILE}" | ansi2html --no-header >> "$GITHUB_STEP_SUMMARY"
        fi
        echo '### Output from STDOUT' >> "$GITHUB_STEP_SUMMARY"
        cat "${OUTPUT_PATH}/output.md" >> "$GITHUB_STEP_SUMMARY"
    - shell: bash
      name: Attach Frontend Bundle to Docker Image
      if: ${{ steps.docker-output-metadata.outputs.web-image != '' && steps.docker-output-metadata.outputs.bundle-path != '' }}
      env:
        WEB_IMAGE: ${{ steps.docker-output-metadata.outputs.web-image }}
        ARTIFACT_PATH: ${{ steps.docker-output-metadata.outputs.bundle-path }}/frontend-bundle.tgz
        ARTIFACT_TYPE: application/vnd.mesh.frontend-bundle.v1+tgz
      run: |
        oras login --username "${{ github.actor }}" --password "${{ inputs.token }}" ghcr.io
        oras attach $WEB_IMAGE \
        --disable-path-validation \
        --artifact-type ${ARTIFACT_TYPE} \
        "${ARTIFACT_PATH}"
